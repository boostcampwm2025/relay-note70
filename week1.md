## 🤖 AI를 학습 및 성장에 활용하는 방법

### 📒 미션에서 AI를 활용하기

- `READ.md` 작성 시 가독성 향상 및 템플릿으로 활용
- 설계 단계에서 점검하기위한 용도
- 바이브 코딩을 통한 예시 코드 생성
- 체크리스트 작성 피드백
- 테스트 케이스 생성
- 로직 개선

### 📌학습에서 AI를 활용하기

- 이론 공부에서 이해를 높이기 위한 예시 생성
- 공부한 내용을 프롬프트로 작성해서 퀴즈 생성
- 얻은 정보를 크로스 체크를 통해 정확한 정보인지 확인하기
- 공부 내용 작성한거를 프롬프트로 작성해서 가독성 좋게 정리하기
- 방대한 내용 요약
- 특정 주제에 대한 검색
- 프로젝트 활용
  - 주가 예상
  - 챗봇 제작
  - 데이터 분석
  - 웹 디자인 제작
  - Mock 데이터 생성

---

### 📜 퀘스트

#### 1. gist 문서 정리에 AI 활용하기

=> 3개중 택 1

- 소스 코드
  - AI에게 코드 주석 요청하기
    - 매일 피어 세션을 하면 서로의 코드를 확인해야하는 만큼 읽기 쉬운 코드를 제작하기 위함
    - 템플릿을 사용가능하다면 해도 됨
    - 추가된 방식을 회고를 통해 표기
- 리드미
  - 회고를 작성한 후 AI에게 잘한 점, 못한 점을 분석하고, 개선 방안 답변 받기
    - 학습과 발전을 위해 아쉬웠 부분과 이를 해결하기 위한 노력
- 체크리스트
  - 학습 체크리스트 초안 작성 후 세분화된 체크리스트 생성하기
    - 학습 분야에 대해 잘 모르는 것이 많을 때 어떤 것을 공부할지 조차 완벽히 알기 힘듦
    - 기본적으로 필요한 것을 체크리스트로 만들고, 세부적으로 꼭 알아야할 것들을 AI를 활용해 정리해보자

#### 2. 학습할 때 사용하기 좋은 프롬프트 만들고 Slack에 공유하기

- 예시
  1.  (웹사이트 URL)에 정리된 내용을 요약해줘
  2.  (자료 정리 내용)을 마크다운 문법으로 가독성 좋게 작성해줘
  3.  (문장) 이 문장을 문맥적으로 매끄럽게 다듬어줘
  4.  (다이어그램 이미지), (설계 내용) 프로젝트에 대한 다이어그램인데, 설계 내용과 비교해서 보기 좋게 다듬어주고 mermaid 코드로 작성해줘

#### 3. 학습목표를 달성하기 위한 세분화 요청하기

- 예시
  (학습목표)와 같이 알아두면 좋을 점들을 수평적으로 세분화 해줘
  (학습목표)을 위해 알아두어야 할 점들을 수직적으로 세분화 해줘

#### 4. AI를 통해 매일 반복 가능한 간단한 루틴으로 학습 내용을 점검하는 습관을 만들어보기

- Step 1. (학습 전) **오늘의 체크포인트 작성**
  - 오늘 수행할 학습 목표를 담은 체크포인트를 구체적으로 작성한다.
- Step 2. (학습 후) **오늘의 리드미 정리**
  - 체크포인트 기반으로 학습 및 미션 수행 내용을 리드미에 상세히 작성한다.
- Step 3. **AI 평가 요청**
  - 작성한 체크포인트와 리드미를 AI에게 전달하고, 평가 기준을 스스로 정해서 AI에게 오늘 나의 학습 점수와 설명 및 피드백을 요청한다.

# Week1 이어받기
### J273_최준환 : 1.AI에게 코드 주석 요청하기

수행 계획 : 코드를 작성할 때 마다 주석을 전부 작성하도록 사용해보겠습니다.

### J298_황은배

#### 수행할 미션

1. gist 문서 정리에 AI 활용하기 - 리드미

- 작성한 리드미를 AI를 통해 잘한 점, 못한 점을 분석하고, 개선 방안 답변 받기
- 학습과 발전을 위해 아쉬웠 부분과 이를 해결하기 위한 노력

베이직을 거쳐 챌린지 과정까지 문서화에 대한 고민은 계속 이어지는 것 같습니다

릴레이 프로젝트를 계기로 문서화에 AI를 활용해보기로 하였습니다

단순히 정보를 얻고 이를 옮겨 적는 것이 아니라

제가 작성한 리드미를 평가받고 어떤 점이 부족한지, 부족하다면 어떻게 개선할 수 있는지 등을 분석하여

앞으로 문서화를 하는 데에 있어 좋은 습관을 만들어갈 수 있을 거라고 예상됩니다



### S034_제민우
- 선택한 미션: `학습 목표를 달성하기 위한 세분화 요청하기`  
- 선택한 이유:  
    - 학습을 하거나 미션 수행 시 우선순위를 잃고, 다른 길로 빠진적이 많았습니다. 
    - 또한 Learning By Doing이라는 부스트캠프의 취지와 달리 이론 학습에 너무 치우친 적이 많았던 것 같습니다.  
    - 따라서 AI의 로드맵을 따라가보며 제 학습 태도를 개선해보고자 선택하게 되었습니다.

# Week1 수행 결과 
### J273_최준환: `AI에게 코드 주석 요청하기`
<details><summary>작성한 프롬프트🔻</summary>
  
  ```js
  class Node {
  constructor(value,next=null) {
    this.value = value;
    this.next = next;
    Object.freeze(this);
  }
}

class LinkedList {
    constructor(node = null) {
        this.head = node;
        Object.freeze(this);
    }
    append(value){
        //일단 값이 들어오면 무조건 새 노드 생성 - 불변성
        const newNode = new Node(value);
        //head가 없으면 새 노드를 head로하는 list 생성
        if(!this.head) {
            return new LinkedList(newNode);
        }
        //head가 있으면 마지막 노드에 새 노드를 연결
        const copeNode = (current)=>{
            if(!current.next) {//다음 노드가 비어 있다면 마지막 노드를 찾았다.
                return new Node(current.value, newNode);
            }
           return new Node(current.value, copeNode(current.next));//그 후 재귀적으로 뒤에서 부터 노드를 이어 붙인다.
        };
        return new LinkedList(copeNode(this.head));//마지막으로 새로 만들어진 LinkedList 반환
        
    }

    insert(index,value){
        
        if(index ===0) {
            const newNode = new Node(value,this.head);
            return new LinkedList(newNode);
        }

        const makenode_insert = (current, i)=> {//current는 node이다.
            if(i<0){
                throw Error("Invalid index");
            }
            if((!current&&i>0)){
                throw Error("Index out of bounds");
            }
            if(i==1){
                return new Node(current.value,new Node(value,current.next));
            }
            return new Node(current.value,makenode_insert(current.next,i-1));
        };
        return new LinkedList(makenode_insert(this.head,index));
    }


    remove(index){
        if(index===0){
            if (!this.head) throw new Error("Index out of bounds");// 놓쳤던 부분이다. 0인 경우도 비어있을 수 있다...
            return new LinkedList(this.head.next);
        }
        const makenode_remove = (current,index) =>{
            if(index<0){
                throw Error("Invalid index");
            }
            if(index>0&&!current){
                throw Error("Index out of bounds");
            }
            if(index ===1){
                return new Node(current.value,current.next.next)//remove는 기존에 존재하던 node를 쓸 수 있다.
            }
            return new Node(current.value,makenode_remove(current.next,index-1));
        };
        return new LinkedList(makenode_remove(this.head,index));
    }

    item(index){
        if(index<0){
            throw Error("Invalid index");
        }
        
        const getNode = (node,index)=>{
            if(!node){
                throw Error("Index out of bounds");
            }
            if(index===0){
                return node.value;
            }
            return getNode(node.next,index-1);
        };
        return getNode(this.head,index);

    }

    clear(){
        return new LinkedList();
    }
}




module.exports = {LinkedList, Node};
```js

위의 LinkedList에 대해서 주석을 달아주겠어?
내가 함수형으로 만들어본거야
</details>

<details>
<summary>AI답변</summary>
```js
  // 노드 클래스: 불변성을 유지하기 위해 생성 후 동결
class Node {
  constructor(value, next = null) {
    this.value = value;  // 현재 노드의 값
    this.next = next;    // 다음 노드를 가리키는 참조
    Object.freeze(this); // 불변성 보장
  }
}

// 연결 리스트 클래스
class LinkedList {
  constructor(node = null) {
    this.head = node;     // 리스트의 시작 노드 (head)
    Object.freeze(this);  // 불변성 보장
  }

  // 값을 리스트 끝에 추가 (새 리스트 반환)
  append(value) {
    const newNode = new Node(value);  // 새 노드 생성

    if (!this.head) {
      // 빈 리스트인 경우 새 노드만 포함한 리스트 반환
      return new LinkedList(newNode);
    }

    // 기존 노드를 재귀적으로 복사하며 새로운 노드를 끝에 연결
    const copeNode = (current) => {
      if (!current.next) {
        return new Node(current.value, newNode);  // 마지막 노드 뒤에 새 노드 연결
      }
      return new Node(current.value, copeNode(current.next)); // 나머지 노드는 그대로 복사
    };

    return new LinkedList(copeNode(this.head)); // 새로운 리스트 반환
  }

  // 특정 위치에 값을 삽입 (새 리스트 반환)
  insert(index, value) {
    if (index === 0) {
      // 0번째 위치 삽입: 새 노드를 head로 설정
      const newNode = new Node(value, this.head);
      return new LinkedList(newNode);
    }

    // 재귀적으로 기존 노드를 복사하며 삽입 위치를 찾아 새로운 노드 연결
    const makenode_insert = (current, i) => {
      if (i < 0) {
        throw Error("Invalid index");
      }
      if (!current && i > 0) {
        throw Error("Index out of bounds");
      }
      if (i == 1) {
        // 다음 위치에 새 노드를 삽입
        return new Node(current.value, new Node(value, current.next));
      }
      return new Node(current.value, makenode_insert(current.next, i - 1));
    };

    return new LinkedList(makenode_insert(this.head, index));
  }

  // 특정 위치의 노드를 제거 (새 리스트 반환)
  remove(index) {
    if (index === 0) {
      if (!this.head) throw new Error("Index out of bounds");
      // head 제거: head의 다음 노드를 새로운 head로 설정
      return new LinkedList(this.head.next);
    }

    // 재귀적으로 기존 노드를 복사하며 제거할 위치를 건너뜀
    const makenode_remove = (current, index) => {
      if (index < 0) {
        throw Error("Invalid index");
      }
      if (index > 0 && !current) {
        throw Error("Index out of bounds");
      }
      if (index === 1) {
        // 다음 노드를 건너뛰어 연결 (삭제 효과)
        return new Node(current.value, current.next.next);
      }
      return new Node(current.value, makenode_remove(current.next, index - 1));
    };

    return new LinkedList(makenode_remove(this.head, index));
  }

  // 특정 인덱스의 값을 조회 (값만 반환)
  item(index) {
    if (index < 0) {
      throw Error("Invalid index");
    }

    const getNode = (node, index) => {
      if (!node) {
        throw Error("Index out of bounds");
      }
      if (index === 0) {
        return node.value;
      }
      return getNode(node.next, index - 1);
    };

    return getNode(this.head, index);
  }

  // 리스트 초기화 (빈 리스트 반환)
  clear() {
    return new LinkedList(); // head가 null인 새 리스트 반환
  }
}

module.exports = { LinkedList, Node };
```
</details>

### J298_황은배: `gist 문서 정리에 AI 활용하기 - 리드미`
### S034_제민우: `학습 목표를 달성하기 위한 세분화 요청하기`  
후기: 명확한 학습 가이드라인이 생긴 덕에 이론 학습에 너무 치우치지 않을 수 있었습니다!  
특히 생소한 개념을 학습할 때 유용하게 써먹을 수 있을 것 같애요😊  

<details>
<summary><b>작성한 프롬프트</b> (🔻 자세히보기)</summary>

```md
나는 iOS 개발을 하고 있는 취준생이야. Swift 문법이나 기본적인 프로그래밍 개념에 대해서는 어느정도 익숙해.

<요청>  
오늘은 함수형 프로그래밍에 대해 학습할거야.  
- 학습 로드맵을 짜줘.
- 같이 알아두면 좋을 점들을 수평적으로 세분화 해줘
- 같이 알아두면 좋을 점들을 수직적으로 세분화 해줘

<학습 후 얻고 싶은 능력>
- 순수 함수 형태로 데이터 구조를 설계하고 기본 동작 알고리즘을 구현할 수 있다.
- 불변성 Immutable 값이나 부작용이 없는 변수를 적극 활용할 수 있다.
- 함수가 참조 투명성을 지키고, 부작용을 줄일 수 있도록 구현할 수 있다.
- 순수함수 Pure Function 으로 구현할 수 있다.
```
</details>  

<details>
<summary><b>제미나이 답변</b> (🔻 자세히보기)</summary>

네, iOS 개발 취업 준비생이시군요! Swift에 익숙하시다니 함수형 프로그래밍을 배우기에 아주 좋은 시작점에 계십니다. 함수형 프로그래밍은 SwiftUI와 Combine 프레임워크의 기반이 되기 때문에 iOS 개발자에게 매우 중요한 역량입니다. 요청하신 내용을 바탕으로 학습 로드맵과 함께 알아두면 좋을 점들을 정리해 드릴게요.

**함수형 프로그래밍 학습 로드맵 🗺️**  
이 로드맵은 함수형 프로그래밍의 핵심 개념을 단계적으로 익히고, 최종적으로 Swift 코드에 자연스럽게 적용하는 것을 목표로 합니다.  
1. **함수형 프로그래밍 기본 개념 이해 (Foundation)**
- 순수 함수 (Pure Function): 동일한 입력에 대해 항상 동일한 출력을 반환하고, 부작용(Side Effect)이 없는 함수입니다. 우선 이 개념을 완벽히 이해하는 데 집중하세요.
- 불변성 (Immutability): let을 사용하여 변경 불가능한 데이터를 만드는 것의 중요성을 이해합니다. 데이터가 변하지 않음으로써 예측 가능하고 안정적인 코드를 작성할 수 있습니다.
- 1급 객체로서의 함수 (First-class Citizen): Swift에서 함수를 변수에 할당하고, 파라미터로 전달하며, 반환 값으로 사용할 수 있다는 점을 복습합니다. 클로저(Closure)와 연관 지어 학습하면 좋습니다.
2. 고차 함수 활용 (Higher-Order Functions)
- Swift의 기본 컬렉션 타입(Array, Dictionary, Set)이 제공하는 map, filter, reduce 사용법을 익힙니다.
- 이 함수들을 사용해서 for 루프를 대체하는 연습을 충분히 해보세요. 코드가 어떻게 더 간결하고 선언적으로 바뀌는지 체감하는 것이 중요합니다.
- compactMap, flatMap 등 다른 유용한 고차 함수들도 함께 학습합니다.
3. 심화 개념 학습 (Advanced Concepts)
- 참조 투명성 (Referential Transparency): 함수 호출을 그 함수의 실행 결과 값으로 대체해도 전체 프로그램의 동작에 영향을 주지 않는 특성입니다. 순수 함수와 깊은 관련이 있으니 함께 이해해야 합니다.
- 커링 (Currying): 여러 개의 파라미터를 받는 함수를, 단일 파라미터를 받는 함수의 연속으로 바꾸는 기법입니다.
- 합성 함수 (Function Composition): 여러 함수를 조합하여 새로운 함수를 만드는 방법을 배웁니다.
4. 실전 적용 및 설계 (Practical Application)
- 학습한 개념을 바탕으로 작은 프로젝트나 알고리즘 문제를 함수형으로 풀어보는 연습을 합니다. (예: 특정 조건에 맞는 데이터 필터링 및 가공, 값 계산 등)
- 상태(State)를 직접 변경하는 대신, 새로운 상태를 생성하여 반환하는 방식으로 데이터 구조를 설계해 봅니다.
- SwiftUI나 Combine을 학습하며 실제 Apple 프레임워크에서 함수형 패러다임이 어떻게 활용되는지 경험해 보세요.
<img width="643" height="542" alt="스크린샷 2025-07-23 오후 2 01 35" src="https://github.com/user-attachments/assets/ad913074-f8ad-4524-9059-c6076340dc79" />

<img width="669" height="639" alt="스크린샷 2025-07-23 오후 2 03 14" src="https://github.com/user-attachments/assets/5ac3cb25-4778-46d6-b6fb-f6bdb526fa92" />

<img width="652" height="328" alt="스크린샷 2025-07-23 오후 2 03 39" src="https://github.com/user-attachments/assets/2ba305bf-3668-4eb8-a116-ef2603254d06" />

</details>
